# 6 语义分析和符号表

## 6.1 语义分析概述

- 语义（semantics）
  - 指为程序单元赋予一定含义时程序应满足的性质
  - 静态语义分析：编译期间所进行的语义分析，如静态类型检查
  - 动态语义分析：程序运行时的语义检查，如动态类型检查
- 静态语义分析任务
  - 静态类型检查
  - 一般性的语义检查

## 6.2 符号表概述

- 符号表：记录标识符语义信息的数据结构
  - 语义信息（属性）：
    - 名字、类型、存储类别、存储位置、符号作用域等
    - 数组的维数、各维的上下界、结构体的成员信息、函数的形参信息等
- 符号表的总体组织
  - 将种类相同的标识符组织在一起，构造多个表
  - 将不同种类的标识符都组织在一张符号表中

- 符号表表项的组织
  - 无序表：按标识符被扫描到的先后顺序填入符号表中
  - 有序表：每次将标识符填入符号表时，均按某个指定的关键字对其进行排序
    - 散列表
    - 二叉树

## 6.3 标识符的属性表示

- 类型标识符的属性表示

  - Name、Kind、Type

- 变量标识符的属性表示

  - Name、Kind、Type
    - Kind：varKind
  - Access：变量的访问方式
    - 直接变量（dir）：地址空间中存放的是值
    - 间接变量（indir）：地址空间中存放的是地址
  - (Level, Offset）：变量的抽象地址
    - 层数（Level）：确定了变量所在的内存块
    - 偏移量（Offset）：确定了变量在内存块的相对地址
    - 约定主程序的层数为 0
    - 约定每层函数中第一个被声明的变量标识符的偏移量为 0，之后按内存大小递增
- Value
  
  

## 6.4 函数标识符的属性表示

- Name、Kind、Type
  - Kind：routKind
- Class：区分是实在函数（actual）还是形参函数（formal）
- (Level, Offset)：只有形参函数才需要分配空间（Offset）
- ParamList：指向当前函数的形参列表的指针
- Code：指向函数对应的目标代码的起始地址
- Size：目标代码的大小

## 6.5 域名标识符的属性表示

- 域名标识符
  - 作用域仅限于所在的结构体
  - 不需要记录层数信息
  - 偏移量：相对于分配给结构体变量的起始地址的偏移量
- 域名标识符的属性信息
  - 登记到符号表中（会有同名冲突）
  - 登记到结构体类型的内部表示中（需要先找结构体，再找域名）

## 6.6 基本类型的内部表示

- 基本类型
  - 整型（int，integer）
  - 实型（float，real）
  - 字符型（char）
  - 布尔型（bool）
- 构造类型
  - 结构体（struct，record）
  - 数组（int A[10]，array A[1..10]）
  - 枚举（enum）
  - 指针（int*）
  - 联合（union，变体记录）
- 基本类型由目标机确定，构造类型由程序定义
- 基本类型（xxxPtr）的内部表示
  - Size、Kind
    - xxxSize、xxxTy

## 6.7 数组类型的内部表示

- 数组类型
  - 变量的有序集合
  - 所有变量具有同一数据类型称为数组的成分类型
  - 有下标
- 数组类型的内部表示
  - Size、Kind
    - Size = sizeof(ElemTy) * (Up - Low + 1)
    - Kind：arrayTy
  - Low、Up：数组的上下界
  - ElemTy：数组的成分类型

## 6.8 结构和联合类型的内部表示

- 结构类型

  - 变量的有序集合
  - 变量可以有多种类型
  - 变量所占空间大小可能不同
  - 运行时分配地址不固定

- 结构类型的内部表示

  - Size、Kind
    - Size 为所有域的类型 Size 之和
    - Kind：structTy
  - Body：域名标识符的内部表示链
    - 域名的内部表示
      - FieldName、FieldType
      - Offset：结构体中相对偏移量
      - Next

- 联合类型

  - 变量的有序集合
  - 变量只有一个有效

  - 所有域名的偏移相同，无需记录

- 联合类型的内部表示

  - Size、Kind
    - Size 为所有域的类型 Size 中的最大值
    - Kind：unionTy
  - Body：域名内部表示无 Offset

## 6.9 枚举类型的内部表示

- 枚举类型
  - 相互独立且用于某方面信息的元素的集合
  - 相对于数据常量定义更直观
  - 通过枚举类型标识符定义了一个整型的常量集合
- 枚举类型的内部表示
  - Size、Kind
    - Kind：enumTy
  - Elist：枚举常量链
    - 枚举常量内部表示
      - itemName、Value、Next

## 6.10 指针类型的内部表示

- 指针类型
  - 任何类型都伴随一个指向本类型变量的指针类型
  - 关注指针所指向的基类型
- 指针类型的内部表示
  - Size、Kind
    - Size：指针的空间大小
    - Kind：pointerTy
  - BaseType：xxxPtr

## 6.11 值的内部表示

- 简单类型
  - 有值的概念，由目标机提供
  - 包括枚举类型
- 构造类型
  - 没有值的概念
  - 指针类型可以有值（地址）的概念

## 6.12 标识符的作用域

- 标识符的作用域

  - 局部化单位：程序中允许有声明的程序段

  - 一般的，在没有局部化单位的嵌套时
    - 作用域从声明该标识符的位置开始
    - 到其所在局部化单位的结束
  - 否则
    - 作用域遵循最近嵌套原则
    - 外层不可访问内层标识符

## 6.13 符号表的局部化

- 符号表的局部化
  - 构造符号表时
  - 保证标识符在其作用域内可被访问到
  - 在其作用域之外则访问不到
- 实现方式
  - 局部符号表
    - 每个局部化单位一张符号表
    - 用一个 scope 栈实现跨局部化单位的访问
  - 全局符号表
    - 整个程序一张符号表
    - 在符号表表项处理时采取一定措施，如
      - 增加标记项使访问略过失效表项
      - 删除失效表项等
- 局部化符号表
  - 建表
    - 初始化 scope 栈为空
    - 每进入新一层局部化单位创建一个新符号表 t
    - 将表的首地址 t.entry 压入 scope 栈
    - 该局部化单位声明的标识符依次填入 t
    - 每当退出一层局部化单位表时
    - 从 scope 栈将该层符号表首地址弹出
  - 查表
    - 从 scope 栈顶所记录符号表开始查找
    - 未找到再从次栈顶所记录表查找
    - 直到找到或所有符号表中都找不到为止

## 6.14 全局化符号表 - 删除法

- 当超出标识符的作用域范围时，删掉标识符对应的表项
- 实现
  - 给每个局部化区赋予一个编号 num
  - 给每个符号表项增加一个属性 num
    - 对应所属局部化区的编号
  - 定义一个全局变量 CurrentNum
    - 初值为 0
    - 记录当前所在局部化区的编号
  - 每当进入一个新的局部化区
    - CurrentNum++
  - 每当遇到标识符的声明
    - 检查符号表中 num = CurrentNum 的表项
    - 判断是否出现重复定义错误
    - 否则将该标识符填入符号表
  - 每当遇到标识符的使用
    - 检查符号表中 num <= CurrentNum 的表项
    - 按 num 从大到小查找标识符
    - 没找到则出现未定义错误
    - 否则最先查到的表项为标识符对应的属性
  - 每当退出一个局部化区
    - num = CurrentNum 的表项
    - CurrentNum--

## 6.15 全局化符号表 - 驻留法

- 以某种方式避免访问不在作用域内的符号
- 实现
  - 总体思路同删除法
  - 当退出一个局部化区
    - 保留当前局部化区的表项
    - 向对应符号表中填入一个标记项
    - 使得查表时跳过无效的表项

## 6.16 全局化符号表 - 散列法

- 删除法的一种，以散列表的方式组织符号表
- 实现
  - 定义适当的散列函数
    - 以标识符的名字为主键
    - 计算标识符的符号表地址
  - 出现多个局部化区有重名标识符
    - 用拉链法处理散列冲突
    - 一般是头插法（外拉链法）

